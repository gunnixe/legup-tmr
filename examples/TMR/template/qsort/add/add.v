//----------------------------------------------------------------------------//
// Generated by LegUp High-Level Synthesis Tool Version 4.0 (http://legup.org)
// Compiled: Fri Nov 25 00:05:27 2016
// University of Toronto
// For research and academic purposes only. Commercial use is prohibited.
// Please send bugs to: legup@eecg.toronto.edu
// Date: Fri Nov 25 22:17:19 2016
//----------------------------------------------------------------------------//

`define MEMORY_CONTROLLER_ADDR_SIZE 32
`define MEMORY_CONTROLLER_DATA_SIZE 64
// Number of RAM elements: 1
`define MEMORY_CONTROLLER_TAG_SIZE 9
// @a = internal unnamed_addr constant [1024 x i32] [i32 2, i32 3, i32 4, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32...
`define TAG_g_a `MEMORY_CONTROLLER_TAG_SIZE'd2
`define TAG_g_a_a {`TAG_g_a, 23'd0}

// Turn off warning 'ignoring unsupported system task'
// altera message_off 10175

`timescale 1 ns / 1 ns
module top
	(
		clk,
		reset,
		start,
		finish,
		waitrequest,
		return_val
	);
input clk;
input reset;
input start;
output wire finish;
input waitrequest;
output wire [31:0] return_val;
wire memory_controller_waitrequest;
wire memory_controller_enable_a;
wire [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_a;
wire memory_controller_write_enable_a;
wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in_a;
wire [1:0] memory_controller_size_a;
wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out_a;

wire memory_controller_enable_b;
wire [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_b;
wire memory_controller_write_enable_b;
wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in_b;
wire [1:0] memory_controller_size_b;
wire [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out_b;

/* synthesis translate_off */
assign memory_controller_waitrequest = waitrequest;
/* synthesis translate_on */

memory_controller memory_controller_inst (
	.clk( clk ),
	.memory_controller_enable_a( memory_controller_enable_a ),
	.memory_controller_enable_b( memory_controller_enable_b ),
	.memory_controller_address_a( memory_controller_address_a ),
	.memory_controller_address_b( memory_controller_address_b ),
	.memory_controller_write_enable_a( memory_controller_write_enable_a ),
	.memory_controller_write_enable_b( memory_controller_write_enable_b ),
	.memory_controller_in_a( memory_controller_in_a ),
	.memory_controller_in_b( memory_controller_in_b ),
	.memory_controller_size_a( memory_controller_size_a ),
	.memory_controller_size_b( memory_controller_size_b ),
	.memory_controller_waitrequest( memory_controller_waitrequest ),
	.memory_controller_out_reg_a( memory_controller_out_a ),
	.memory_controller_out_reg_b( memory_controller_out_b )
);

main main_inst(
	.clk( clk ),
	.clk2x( clk2x ),
	.clk1x_follower( clk1x_follower ),
	.reset( reset ),
	.start( start ),
	.finish( finish ),
	.return_val( return_val ),
	.memory_controller_waitrequest(memory_controller_waitrequest),
	.memory_controller_enable_a(memory_controller_enable_a),
	.memory_controller_address_a(memory_controller_address_a),
	.memory_controller_write_enable_a(memory_controller_write_enable_a),
	.memory_controller_in_a(memory_controller_in_a),
	.memory_controller_size_a(memory_controller_size_a),
	.memory_controller_out_a(memory_controller_out_a),
	.memory_controller_enable_b(memory_controller_enable_b),
	.memory_controller_address_b(memory_controller_address_b),
	.memory_controller_write_enable_b(memory_controller_write_enable_b),
	.memory_controller_in_b(memory_controller_in_b),
	.memory_controller_size_b(memory_controller_size_b),
	.memory_controller_out_b(memory_controller_out_b)
);

endmodule

`timescale 1 ns / 1 ns
module memory_controller
(
	clk,
	memory_controller_address_a,
	memory_controller_address_b,
	memory_controller_enable_a,
	memory_controller_enable_b,
	memory_controller_write_enable_a,
	memory_controller_write_enable_b,
	memory_controller_in_a,
	memory_controller_in_b,
	memory_controller_size_a,
	memory_controller_size_b,
	memory_controller_waitrequest,
	memory_controller_out_reg_a,
	memory_controller_out_reg_b
);

parameter latency = 2;

parameter ram_latency = latency-1;

integer j;

input clk;
input memory_controller_waitrequest;
input [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_a;
input memory_controller_enable_a;
input memory_controller_write_enable_a;
input [64-1:0] memory_controller_in_a;
input [1:0] memory_controller_size_a;
output reg [64-1:0] memory_controller_out_reg_a;
reg [64-1:0] memory_controller_out_prev_a;
reg [64-1:0] memory_controller_out_a;

reg memory_controller_enable_reg_a;
input [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_b;
input memory_controller_enable_b;
input memory_controller_write_enable_b;
input [64-1:0] memory_controller_in_b;
input [1:0] memory_controller_size_b;
output reg [64-1:0] memory_controller_out_reg_b;
reg [64-1:0] memory_controller_out_prev_b;
reg [64-1:0] memory_controller_out_b;

reg memory_controller_enable_reg_b;

reg [9:0] a_address_a;
reg [9:0] a_address_b;
reg a_write_enable_a;
reg a_write_enable_b;
reg [31:0] a_in_a;
reg [31:0] a_in_b;
wire [31:0] a_out_a;
wire [31:0] a_out_b;

// @a = internal unnamed_addr constant [1024 x i32] [i32 2, i32 3, i32 4, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32...
rom_dual_port a (
	.clk( clk ),
	.clken( !memory_controller_waitrequest ),
	.address_a( a_address_a ),
	.address_b( a_address_b ),
	.q_a( a_out_a ),
	.q_b( a_out_b )
);
defparam a.width_a = 32;
defparam a.width_b = 32;
defparam a.widthad_a = 10;
defparam a.widthad_b = 10;
defparam a.numwords_a = 1024;
defparam a.numwords_b = 1024;
defparam a.latency = ram_latency;
defparam a.init_file = "a.mif";
wire [`MEMORY_CONTROLLER_TAG_SIZE-1:0] tag_a;
assign tag_a = memory_controller_address_a[`MEMORY_CONTROLLER_ADDR_SIZE-1:`MEMORY_CONTROLLER_ADDR_SIZE-`MEMORY_CONTROLLER_TAG_SIZE];
reg [2:0] prevAddr_a;
reg [1:0] prevSize_a;
reg [2:0] prevSize_a_and;

always @(posedge clk)
if (!memory_controller_waitrequest)
begin
	prevAddr_a <= memory_controller_address_a[2:0];
	prevSize_a <= memory_controller_size_a;
end
wire [`MEMORY_CONTROLLER_TAG_SIZE-1:0] tag_b;
assign tag_b = memory_controller_address_b[`MEMORY_CONTROLLER_ADDR_SIZE-1:`MEMORY_CONTROLLER_ADDR_SIZE-`MEMORY_CONTROLLER_TAG_SIZE];
reg [2:0] prevAddr_b;
reg [1:0] prevSize_b;
reg [2:0] prevSize_b_and;

always @(posedge clk)
if (!memory_controller_waitrequest)
begin
	prevAddr_b <= memory_controller_address_b[2:0];
	prevSize_b <= memory_controller_size_b;
end

reg [2:0] select_not_struct_a;

wire select_a_a;
assign select_a_a = (tag_a == `TAG_g_a);
reg [ram_latency:0] select_a_reg_a;
wire [31:0] memory_controller_a_out_a;
assign memory_controller_a_out_a = {32{ select_a_reg_a[ram_latency]}} & a_out_a;

always @(*)
begin
	a_address_a = memory_controller_address_a [10-1+2:2] & {10{select_a_a}};
	a_write_enable_a = memory_controller_write_enable_a & select_a_a;
	a_in_a [32-1:0] = memory_controller_in_a[32-1:0];

end
always @(*)
begin
	select_not_struct_a [2:0] = 3'b0 | {2{select_a_reg_a[ram_latency]}};
	if (prevAddr_a[2:0] & select_not_struct_a[2:0] != 0 && memory_controller_enable_a)
	begin
		$display("Error: memory address not aligned to ram word size!");
		$finish;
	end

	prevSize_a_and[0] = prevSize_a[1] | prevSize_a[0];
	prevSize_a_and[1] = prevSize_a[1];
	prevSize_a_and[2] = prevSize_a[1] & prevSize_a[0];
	if ((prevAddr_a & prevSize_a_and) != 0 && memory_controller_enable_a)
	begin
		$display("Error: memory address not aligned to ram word size!");
		$finish;
	end
	memory_controller_out_prev_a = memory_controller_out_reg_a & { 64{!memory_controller_enable_reg_a}};
	memory_controller_out_a = 1'b0 | memory_controller_out_prev_a | memory_controller_a_out_a;
end

always @(posedge clk)
if (!memory_controller_waitrequest)
begin
memory_controller_out_reg_a <= memory_controller_out_a;
memory_controller_enable_reg_a <= memory_controller_enable_a;
end

always @(posedge clk)
if (!memory_controller_waitrequest)
for (j = 0; j < ram_latency; j=j+1)
begin
select_a_reg_a[j+1] <= select_a_reg_a[j];
end
always @(*)
begin
select_a_reg_a[0] <= select_a_a;
end

reg [2:0] select_not_struct_b;

wire select_a_b;
assign select_a_b = (tag_b == `TAG_g_a);
reg [ram_latency:0] select_a_reg_b;
wire [31:0] memory_controller_a_out_b;
assign memory_controller_a_out_b = {32{ select_a_reg_b[ram_latency]}} & a_out_b;

always @(*)
begin
	a_address_b = memory_controller_address_b [10-1+2:2] & {10{select_a_b}};
	a_write_enable_b = memory_controller_write_enable_b & select_a_b;
	a_in_b [32-1:0] = memory_controller_in_b[32-1:0];

end
always @(*)
begin
	select_not_struct_b [2:0] = 3'b0 | {2{select_a_reg_b[ram_latency]}};
	if (prevAddr_b[2:0] & select_not_struct_b[2:0] != 0 && memory_controller_enable_b)
	begin
		$display("Error: memory address not aligned to ram word size!");
		$finish;
	end

	prevSize_b_and[0] = prevSize_b[1] | prevSize_b[0];
	prevSize_b_and[1] = prevSize_b[1];
	prevSize_b_and[2] = prevSize_b[1] & prevSize_b[0];
	if ((prevAddr_b & prevSize_b_and) != 0 && memory_controller_enable_b)
	begin
		$display("Error: memory address not aligned to ram word size!");
		$finish;
	end
	memory_controller_out_prev_b = memory_controller_out_reg_b & { 64{!memory_controller_enable_reg_b}};
	memory_controller_out_b = 1'b0 | memory_controller_out_prev_b | memory_controller_a_out_b;
end

always @(posedge clk)
if (!memory_controller_waitrequest)
begin
memory_controller_out_reg_b <= memory_controller_out_b;
memory_controller_enable_reg_b <= memory_controller_enable_b;
end

always @(posedge clk)
if (!memory_controller_waitrequest)
for (j = 0; j < ram_latency; j=j+1)
begin
select_a_reg_b[j+1] <= select_a_reg_b[j];
end
always @(*)
begin
select_a_reg_b[0] <= select_a_b;
end

endmodule 

`timescale 1 ns / 1 ns
module main
(
	clk,
	clk2x,
	clk1x_follower,
	reset,
	start,
	finish,
	memory_controller_waitrequest,
	memory_controller_enable_a,
	memory_controller_address_a,
	memory_controller_write_enable_a,
	memory_controller_in_a,
	memory_controller_size_a,
	memory_controller_out_a,
	memory_controller_enable_b,
	memory_controller_address_b,
	memory_controller_write_enable_b,
	memory_controller_in_b,
	memory_controller_size_b,
	memory_controller_out_b,
	return_val
);

parameter [2:0] LEGUP_0 = 3'd0;
parameter [2:0] LEGUP_F_main_BB__1_1 = 3'd1;
parameter [2:0] LEGUP_F_main_BB__1_2 = 3'd2;
parameter [2:0] LEGUP_F_main_BB__1_3 = 3'd3;
parameter [2:0] LEGUP_F_main_BB__5_4 = 3'd4;
parameter [2:0] LEGUP_F_main_BB__8_5 = 3'd5;
parameter [2:0] LEGUP_F_main_BB__10_6 = 3'd6;
parameter [2:0] LEGUP_F_main_BB__12_7 = 3'd7;
parameter [8:0] tag_offset = 9'd0;
parameter [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] tag_addr_offset = {tag_offset, 23'd0};
integer i;

input  clk;
input  clk2x;
input  clk1x_follower;
input  reset;
input  start;
output reg  finish;
input  memory_controller_waitrequest;
output reg  memory_controller_enable_a;
output reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_a;
output reg  memory_controller_write_enable_a;
output reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in_a;
output reg [1:0] memory_controller_size_a;
input [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out_a;
output reg  memory_controller_enable_b;
output reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] memory_controller_address_b;
output reg  memory_controller_write_enable_b;
output reg [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_in_b;
output reg [1:0] memory_controller_size_b;
input [`MEMORY_CONTROLLER_DATA_SIZE-1:0] memory_controller_out_b;
output reg [31:0] return_val;
reg [2:0] cur_state;
reg [2:0] next_state;
reg [2:0] cur_state_r0, cur_state_r1, cur_state_r2 /*synthesis keep*/;
reg [2:0] cur_state_v0, cur_state_v1, cur_state_v2 /*synthesis keep*/;
always @(*) begin
	for(i=0; i<=2; i=i+1) begin
		cur_state_v0[i] = (cur_state_r0[i]==cur_state_r1[i])? cur_state_r0[i]
			: cur_state_r2[i];
		cur_state_v1[i] = (cur_state_r0[i]==cur_state_r1[i])? cur_state_r0[i]
			: cur_state_r2[i];
		cur_state_v2[i] = (cur_state_r0[i]==cur_state_r1[i])? cur_state_r0[i]
			: cur_state_r2[i];
	end
end
reg [2:0] next_state_r0, next_state_r1, next_state_r2 /*synthesis keep*/;

reg [31:0] main_1_r02;
reg [31:0] main_1_r02_r0, main_1_r02_r1, main_1_r02_r2 /*synthesis keep*/;

reg [31:0] main_1_r02_reg;
reg [31:0] main_1_r02_reg_r0, main_1_r02_reg_r1, main_1_r02_reg_r2 /*synthesis keep*/;
reg [31:0] main_1_r02_reg_v0, main_1_r02_reg_v1, main_1_r02_reg_v2 /*synthesis keep*/;
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
		main_1_r02_reg_v0[i] = (main_1_r02_reg_r0[i]==main_1_r02_reg_r1[i])? main_1_r02_reg_r0[i]
			: main_1_r02_reg_r2[i];
		main_1_r02_reg_v1[i] = (main_1_r02_reg_r0[i]==main_1_r02_reg_r1[i])? main_1_r02_reg_r0[i]
			: main_1_r02_reg_r2[i];
		main_1_r02_reg_v2[i] = (main_1_r02_reg_r0[i]==main_1_r02_reg_r1[i])? main_1_r02_reg_r0[i]
			: main_1_r02_reg_r2[i];
	end
end

reg [31:0] main_1_i01;
reg [31:0] main_1_i01_r0, main_1_i01_r1, main_1_i01_r2 /*synthesis keep*/;

reg [31:0] main_1_i01_reg;
reg [31:0] main_1_i01_reg_r0, main_1_i01_reg_r1, main_1_i01_reg_r2 /*synthesis keep*/;
reg [31:0] main_1_i01_reg_v0, main_1_i01_reg_v1, main_1_i01_reg_v2 /*synthesis keep*/;
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
		main_1_i01_reg_v0[i] = (main_1_i01_reg_r0[i]==main_1_i01_reg_r1[i])? main_1_i01_reg_r0[i]
			: main_1_i01_reg_r2[i];
		main_1_i01_reg_v1[i] = (main_1_i01_reg_r0[i]==main_1_i01_reg_r1[i])? main_1_i01_reg_r0[i]
			: main_1_i01_reg_r2[i];
		main_1_i01_reg_v2[i] = (main_1_i01_reg_r0[i]==main_1_i01_reg_r1[i])? main_1_i01_reg_r0[i]
			: main_1_i01_reg_r2[i];
	end
end

reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep;
reg [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] main_1_scevgep_r0, main_1_scevgep_r1, main_1_scevgep_r2 /*synthesis keep*/;

reg [31:0] main_1_2;
reg [31:0] main_1_2_r0, main_1_2_r1, main_1_2_r2 /*synthesis keep*/;

reg [31:0] main_1_3;
reg [31:0] main_1_3_r0, main_1_3_r1, main_1_3_r2 /*synthesis keep*/;

reg [31:0] main_1_3_reg;
reg [31:0] main_1_3_reg_r0, main_1_3_reg_r1, main_1_3_reg_r2 /*synthesis keep*/;

reg [31:0] main_1_4;
reg [31:0] main_1_4_r0, main_1_4_r1, main_1_4_r2 /*synthesis keep*/;

reg [31:0] main_1_4_reg;
reg [31:0] main_1_4_reg_r0, main_1_4_reg_r1, main_1_4_reg_r2 /*synthesis keep*/;

reg  main_1_exitcond1;
reg  main_1_exitcond1_r0, main_1_exitcond1_r1, main_1_exitcond1_r2 /*synthesis keep*/;

reg  main_1_exitcond1_reg;
reg  main_1_exitcond1_reg_r0, main_1_exitcond1_reg_r1, main_1_exitcond1_reg_r2 /*synthesis keep*/;

reg  main_5_7;
reg  main_5_7_r0, main_5_7_r1, main_5_7_r2 /*synthesis keep*/;


/* Unsynthesizable Statements */
always @(posedge clk)
	if (!memory_controller_waitrequest) begin
	/* main: %5*/
	/*   %6 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([12 x i8]* @.str1, i32 0, i32 0), i32 %3) #2*/
	if ((cur_state == LEGUP_F_main_BB__5_4)) begin
		$write("Cycle: %d Time: %d    ", ($time-50)/20, $time);
$write("Result: %d\n", $signed(main_1_3_reg));
		// to fix quartus warning
		if (reset == 1'b0 && ^(main_1_3_reg) === 1'bX) finish <= 0;
	end
	/* main: %8*/
	/*   %9 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([14 x i8]* @.str2, i32 0, i32 0)) #2*/
	if ((cur_state == LEGUP_F_main_BB__8_5)) begin
		$write("Cycle: %d Time: %d    ", ($time-50)/20, $time);
$write("RESULT: PASS\n");
	end
	/* main: %10*/
	/*   %11 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([14 x i8]* @.str3, i32 0, i32 0)) #2*/
	if ((cur_state == LEGUP_F_main_BB__10_6)) begin
		$write("Cycle: %d Time: %d    ", ($time-50)/20, $time);
$write("RESULT: FAIL\n");
	end
end
always @(posedge clk) begin
	if (reset)
		cur_state_r0 <= LEGUP_0;
	else if (memory_controller_waitrequest == 1'd1)
		cur_state_r0 <= cur_state_r0;
	else
		cur_state_r0 <= next_state_r0;
end

always @(*)
begin
next_state_r0 = cur_state_r0;
case(cur_state_v0)  // synthesis parallel_case  
LEGUP_0:
	if ((start == 1'd1))
		next_state_r0 = LEGUP_F_main_BB__1_1;
LEGUP_F_main_BB__10_6:
		next_state_r0 = LEGUP_F_main_BB__12_7;
LEGUP_F_main_BB__12_7:
		next_state_r0 = LEGUP_0;
LEGUP_F_main_BB__1_1:
		next_state_r0 = LEGUP_F_main_BB__1_2;
LEGUP_F_main_BB__1_2:
		next_state_r0 = LEGUP_F_main_BB__1_3;
LEGUP_F_main_BB__1_3:
	if ((main_1_exitcond1_reg_r0 == 1'd1))
		next_state_r0 = LEGUP_F_main_BB__5_4;
	else if ((main_1_exitcond1_reg_r0 == 1'd0))
		next_state_r0 = LEGUP_F_main_BB__1_1;
LEGUP_F_main_BB__5_4:
	if ((main_5_7_r0 == 1'd1))
		next_state_r0 = LEGUP_F_main_BB__8_5;
	else if ((main_5_7_r0 == 1'd0))
		next_state_r0 = LEGUP_F_main_BB__10_6;
LEGUP_F_main_BB__8_5:
		next_state_r0 = LEGUP_F_main_BB__12_7;
default:
	next_state_r0 = cur_state_r0;
endcase

end
always @(posedge clk) begin
	if (reset)
		cur_state_r1 <= LEGUP_0;
	else if (memory_controller_waitrequest == 1'd1)
		cur_state_r1 <= cur_state_r1;
	else
		cur_state_r1 <= next_state_r1;
end

always @(*)
begin
next_state_r1 = cur_state_r1;
case(cur_state_v1)  // synthesis parallel_case  
LEGUP_0:
	if ((start == 1'd1))
		next_state_r1 = LEGUP_F_main_BB__1_1;
LEGUP_F_main_BB__10_6:
		next_state_r1 = LEGUP_F_main_BB__12_7;
LEGUP_F_main_BB__12_7:
		next_state_r1 = LEGUP_0;
LEGUP_F_main_BB__1_1:
		next_state_r1 = LEGUP_F_main_BB__1_2;
LEGUP_F_main_BB__1_2:
		next_state_r1 = LEGUP_F_main_BB__1_3;
LEGUP_F_main_BB__1_3:
	if ((main_1_exitcond1_reg_r1 == 1'd1))
		next_state_r1 = LEGUP_F_main_BB__5_4;
	else if ((main_1_exitcond1_reg_r1 == 1'd0))
		next_state_r1 = LEGUP_F_main_BB__1_1;
LEGUP_F_main_BB__5_4:
	if ((main_5_7_r1 == 1'd1))
		next_state_r1 = LEGUP_F_main_BB__8_5;
	else if ((main_5_7_r1 == 1'd0))
		next_state_r1 = LEGUP_F_main_BB__10_6;
LEGUP_F_main_BB__8_5:
		next_state_r1 = LEGUP_F_main_BB__12_7;
default:
	next_state_r1 = cur_state_r1;
endcase

end
always @(posedge clk) begin
	if (reset)
		cur_state_r2 <= LEGUP_0;
	else if (memory_controller_waitrequest == 1'd1)
		cur_state_r2 <= cur_state_r2;
	else
		cur_state_r2 <= next_state_r2;
end

always @(*)
begin
next_state_r2 = cur_state_r2;
case(cur_state_v2)  // synthesis parallel_case  
LEGUP_0:
	if ((start == 1'd1))
		next_state_r2 = LEGUP_F_main_BB__1_1;
LEGUP_F_main_BB__10_6:
		next_state_r2 = LEGUP_F_main_BB__12_7;
LEGUP_F_main_BB__12_7:
		next_state_r2 = LEGUP_0;
LEGUP_F_main_BB__1_1:
		next_state_r2 = LEGUP_F_main_BB__1_2;
LEGUP_F_main_BB__1_2:
		next_state_r2 = LEGUP_F_main_BB__1_3;
LEGUP_F_main_BB__1_3:
	if ((main_1_exitcond1_reg_r2 == 1'd1))
		next_state_r2 = LEGUP_F_main_BB__5_4;
	else if ((main_1_exitcond1_reg_r2 == 1'd0))
		next_state_r2 = LEGUP_F_main_BB__1_1;
LEGUP_F_main_BB__5_4:
	if ((main_5_7_r2 == 1'd1))
		next_state_r2 = LEGUP_F_main_BB__8_5;
	else if ((main_5_7_r2 == 1'd0))
		next_state_r2 = LEGUP_F_main_BB__10_6;
LEGUP_F_main_BB__8_5:
		next_state_r2 = LEGUP_F_main_BB__12_7;
default:
	next_state_r2 = cur_state_r2;
endcase

end
always @(*) begin
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	if ((((cur_state_v0 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_r02_r0 = 32'd0;
	end
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else /* if ((((cur_state_v0 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r0 == 1'd0))) */ begin
		main_1_r02_r0 = main_1_3_r0;
	end
end
always @(*) begin
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	if ((((cur_state_v1 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_r02_r1 = 32'd0;
	end
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else /* if ((((cur_state_v1 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r1 == 1'd0))) */ begin
		main_1_r02_r1 = main_1_3_r1;
	end
end
always @(*) begin
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	if ((((cur_state_v2 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_r02_r2 = 32'd0;
	end
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else /* if ((((cur_state_v2 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r2 == 1'd0))) */ begin
		main_1_r02_r2 = main_1_3_r2;
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_r02_reg_r0 <= 0;
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else if((((cur_state_v0 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_r02_reg_r0 <= main_1_r02_r0;
		if (start == 1'b0 && ^(main_1_r02_r0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_r02_reg_r0"); $finish; end
	end
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else if((((cur_state_v0 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r0 == 1'd0))) begin
		main_1_r02_reg_r0 <= main_1_r02_r0;
		if (start == 1'b0 && ^(main_1_r02_r0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_r02_reg_r0"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_r02_reg_r1 <= 0;
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else if((((cur_state_v1 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_r02_reg_r1 <= main_1_r02_r1;
		if (start == 1'b0 && ^(main_1_r02_r1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_r02_reg_r1"); $finish; end
	end
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else if((((cur_state_v1 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r1 == 1'd0))) begin
		main_1_r02_reg_r1 <= main_1_r02_r1;
		if (start == 1'b0 && ^(main_1_r02_r1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_r02_reg_r1"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_r02_reg_r2 <= 0;
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else if((((cur_state_v2 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_r02_reg_r2 <= main_1_r02_r2;
		if (start == 1'b0 && ^(main_1_r02_r2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_r02_reg_r2"); $finish; end
	end
	/* main: %1*/
	/*   %r.02 = phi i32 [ 0, %0 ], [ %3, %1 ]*/
	else if((((cur_state_v2 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r2 == 1'd0))) begin
		main_1_r02_reg_r2 <= main_1_r02_r2;
		if (start == 1'b0 && ^(main_1_r02_r2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_r02_reg_r2"); $finish; end
	end
end
always @(*) begin
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	if ((((cur_state_v0 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_i01_r0 = 32'd0;
	end
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else /* if ((((cur_state_v0 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r0 == 1'd0))) */ begin
		main_1_i01_r0 = main_1_4_reg_r0;
	end
end
always @(*) begin
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	if ((((cur_state_v1 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_i01_r1 = 32'd0;
	end
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else /* if ((((cur_state_v1 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r1 == 1'd0))) */ begin
		main_1_i01_r1 = main_1_4_reg_r1;
	end
end
always @(*) begin
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	if ((((cur_state_v2 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_i01_r2 = 32'd0;
	end
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else /* if ((((cur_state_v2 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r2 == 1'd0))) */ begin
		main_1_i01_r2 = main_1_4_reg_r2;
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_i01_reg_r0 <= 0;
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else if((((cur_state_v0 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_i01_reg_r0 <= main_1_i01_r0;
		if (start == 1'b0 && ^(main_1_i01_r0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_i01_reg_r0"); $finish; end
	end
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else if((((cur_state_v0 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r0 == 1'd0))) begin
		main_1_i01_reg_r0 <= main_1_i01_r0;
		if (start == 1'b0 && ^(main_1_i01_r0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_i01_reg_r0"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_i01_reg_r1 <= 0;
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else if((((cur_state_v1 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_i01_reg_r1 <= main_1_i01_r1;
		if (start == 1'b0 && ^(main_1_i01_r1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_i01_reg_r1"); $finish; end
	end
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else if((((cur_state_v1 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r1 == 1'd0))) begin
		main_1_i01_reg_r1 <= main_1_i01_r1;
		if (start == 1'b0 && ^(main_1_i01_r1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_i01_reg_r1"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_i01_reg_r2 <= 0;
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else if((((cur_state_v2 == LEGUP_0) & (memory_controller_waitrequest == 1'd0)) & (start == 1'd1))) begin
		main_1_i01_reg_r2 <= main_1_i01_r2;
		if (start == 1'b0 && ^(main_1_i01_r2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_i01_reg_r2"); $finish; end
	end
	/* main: %1*/
	/*   %i.01 = phi i32 [ 0, %0 ], [ %4, %1 ]*/
	else if((((cur_state_v2 == LEGUP_F_main_BB__1_3) & (memory_controller_waitrequest == 1'd0)) & (main_1_exitcond1_reg_r2 == 1'd0))) begin
		main_1_i01_reg_r2 <= main_1_i01_r2;
		if (start == 1'b0 && ^(main_1_i01_r2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_i01_reg_r2"); $finish; end
	end
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep = getelementptr [1024 x i32]* @a, i32 0, i32 %i.01*/
		main_1_scevgep_r0 = (`TAG_g_a_a + (4 * main_1_i01_reg_v0));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep = getelementptr [1024 x i32]* @a, i32 0, i32 %i.01*/
		main_1_scevgep_r1 = (`TAG_g_a_a + (4 * main_1_i01_reg_v1));
end
always @(*) begin
	/* main: %1*/
	/*   %scevgep = getelementptr [1024 x i32]* @a, i32 0, i32 %i.01*/
		main_1_scevgep_r2 = (`TAG_g_a_a + (4 * main_1_i01_reg_v2));
end
always @(*) begin
	/* main: %1*/
	/*   %2 = load i32* %scevgep, align 4, !tbaa !1*/
		main_1_2_r0 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %2 = load i32* %scevgep, align 4, !tbaa !1*/
		main_1_2_r1 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %2 = load i32* %scevgep, align 4, !tbaa !1*/
		main_1_2_r2 = memory_controller_out_a[31:0];
end
always @(*) begin
	/* main: %1*/
	/*   %3 = add i32 %2, %r.02*/
		main_1_3_r0 = (main_1_2_r0 + main_1_r02_reg_v0);
end
always @(*) begin
	/* main: %1*/
	/*   %3 = add i32 %2, %r.02*/
		main_1_3_r1 = (main_1_2_r1 + main_1_r02_reg_v1);
end
always @(*) begin
	/* main: %1*/
	/*   %3 = add i32 %2, %r.02*/
		main_1_3_r2 = (main_1_2_r2 + main_1_r02_reg_v2);
end
always @(posedge clk) begin
	if (reset)
		main_1_3_reg_r0 <= 0;
	/* main: %1*/
	/*   %3 = add i32 %2, %r.02*/
	else if((cur_state_v0 == LEGUP_F_main_BB__1_3)) begin
		main_1_3_reg_r0 <= main_1_3_r0;
		if (start == 1'b0 && ^(main_1_3_r0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_3_reg_r0"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_3_reg_r1 <= 0;
	/* main: %1*/
	/*   %3 = add i32 %2, %r.02*/
	else if((cur_state_v1 == LEGUP_F_main_BB__1_3)) begin
		main_1_3_reg_r1 <= main_1_3_r1;
		if (start == 1'b0 && ^(main_1_3_r1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_3_reg_r1"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_3_reg_r2 <= 0;
	/* main: %1*/
	/*   %3 = add i32 %2, %r.02*/
	else if((cur_state_v2 == LEGUP_F_main_BB__1_3)) begin
		main_1_3_reg_r2 <= main_1_3_r2;
		if (start == 1'b0 && ^(main_1_3_r2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_3_reg_r2"); $finish; end
	end
end
always @(*) begin
	/* main: %1*/
	/*   %4 = add nsw i32 %i.01, 1*/
		main_1_4_r0 = (main_1_i01_reg_v0 + 32'd1);
end
always @(*) begin
	/* main: %1*/
	/*   %4 = add nsw i32 %i.01, 1*/
		main_1_4_r1 = (main_1_i01_reg_v1 + 32'd1);
end
always @(*) begin
	/* main: %1*/
	/*   %4 = add nsw i32 %i.01, 1*/
		main_1_4_r2 = (main_1_i01_reg_v2 + 32'd1);
end
always @(posedge clk) begin
	if (reset)
		main_1_4_reg_r0 <= 0;
	/* main: %1*/
	/*   %4 = add nsw i32 %i.01, 1*/
	else if((cur_state_v0 == LEGUP_F_main_BB__1_1)) begin
		main_1_4_reg_r0 <= main_1_4_r0;
		if (start == 1'b0 && ^(main_1_4_r0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_4_reg_r0"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_4_reg_r1 <= 0;
	/* main: %1*/
	/*   %4 = add nsw i32 %i.01, 1*/
	else if((cur_state_v1 == LEGUP_F_main_BB__1_1)) begin
		main_1_4_reg_r1 <= main_1_4_r1;
		if (start == 1'b0 && ^(main_1_4_r1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_4_reg_r1"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_4_reg_r2 <= 0;
	/* main: %1*/
	/*   %4 = add nsw i32 %i.01, 1*/
	else if((cur_state_v2 == LEGUP_F_main_BB__1_1)) begin
		main_1_4_reg_r2 <= main_1_4_r2;
		if (start == 1'b0 && ^(main_1_4_r2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_4_reg_r2"); $finish; end
	end
end
always @(*) begin
	/* main: %1*/
	/*   %exitcond1 = icmp eq i32 %4, 1024*/
		main_1_exitcond1_r0 = (main_1_4_r0 == 32'd1024);
end
always @(*) begin
	/* main: %1*/
	/*   %exitcond1 = icmp eq i32 %4, 1024*/
		main_1_exitcond1_r1 = (main_1_4_r1 == 32'd1024);
end
always @(*) begin
	/* main: %1*/
	/*   %exitcond1 = icmp eq i32 %4, 1024*/
		main_1_exitcond1_r2 = (main_1_4_r2 == 32'd1024);
end
always @(posedge clk) begin
	if (reset)
		main_1_exitcond1_reg_r0 <= 0;
	/* main: %1*/
	/*   %exitcond1 = icmp eq i32 %4, 1024*/
	else if((cur_state_v0 == LEGUP_F_main_BB__1_1)) begin
		main_1_exitcond1_reg_r0 <= main_1_exitcond1_r0;
		if (start == 1'b0 && ^(main_1_exitcond1_r0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_exitcond1_reg_r0"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_exitcond1_reg_r1 <= 0;
	/* main: %1*/
	/*   %exitcond1 = icmp eq i32 %4, 1024*/
	else if((cur_state_v1 == LEGUP_F_main_BB__1_1)) begin
		main_1_exitcond1_reg_r1 <= main_1_exitcond1_r1;
		if (start == 1'b0 && ^(main_1_exitcond1_r1) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_exitcond1_reg_r1"); $finish; end
	end
end
always @(posedge clk) begin
	if (reset)
		main_1_exitcond1_reg_r2 <= 0;
	/* main: %1*/
	/*   %exitcond1 = icmp eq i32 %4, 1024*/
	else if((cur_state_v2 == LEGUP_F_main_BB__1_1)) begin
		main_1_exitcond1_reg_r2 <= main_1_exitcond1_r2;
		if (start == 1'b0 && ^(main_1_exitcond1_r2) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to main_1_exitcond1_reg_r2"); $finish; end
	end
end
always @(*) begin
	/* main: %5*/
	/*   %7 = icmp eq i32 %3, 2051*/
		main_5_7_r0 = (main_1_3_reg_r0 == 32'd2051);
end
always @(*) begin
	/* main: %5*/
	/*   %7 = icmp eq i32 %3, 2051*/
		main_5_7_r1 = (main_1_3_reg_r1 == 32'd2051);
end
always @(*) begin
	/* main: %5*/
	/*   %7 = icmp eq i32 %3, 2051*/
		main_5_7_r2 = (main_1_3_reg_r2 == 32'd2051);
end


//voter
always @(*) begin
	for(i=0; i<=2; i=i+1) begin
	cur_state[i]
		= (cur_state_r0[i]==cur_state_r1[i])? cur_state_r0[i]
		: cur_state_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_r02[i]
		= (main_1_r02_r0[i]==main_1_r02_r1[i])? main_1_r02_r0[i]
		: main_1_r02_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_r02_reg[i]
		= (main_1_r02_reg_r0[i]==main_1_r02_reg_r1[i])? main_1_r02_reg_r0[i]
		: main_1_r02_reg_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_i01[i]
		= (main_1_i01_r0[i]==main_1_i01_r1[i])? main_1_i01_r0[i]
		: main_1_i01_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_i01_reg[i]
		= (main_1_i01_reg_r0[i]==main_1_i01_reg_r1[i])? main_1_i01_reg_r0[i]
		: main_1_i01_reg_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=`MEMORY_CONTROLLER_ADDR_SIZE-1; i=i+1) begin
	main_1_scevgep[i]
		= (main_1_scevgep_r0[i]==main_1_scevgep_r1[i])? main_1_scevgep_r0[i]
		: main_1_scevgep_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_2[i]
		= (main_1_2_r0[i]==main_1_2_r1[i])? main_1_2_r0[i]
		: main_1_2_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_3[i]
		= (main_1_3_r0[i]==main_1_3_r1[i])? main_1_3_r0[i]
		: main_1_3_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_3_reg[i]
		= (main_1_3_reg_r0[i]==main_1_3_reg_r1[i])? main_1_3_reg_r0[i]
		: main_1_3_reg_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_4[i]
		= (main_1_4_r0[i]==main_1_4_r1[i])? main_1_4_r0[i]
		: main_1_4_r2[i];
	end
end
always @(*) begin
	for(i=0; i<=31; i=i+1) begin
	main_1_4_reg[i]
		= (main_1_4_reg_r0[i]==main_1_4_reg_r1[i])? main_1_4_reg_r0[i]
		: main_1_4_reg_r2[i];
	end
end
always @(*) begin
	main_1_exitcond1
		= (main_1_exitcond1_r0==main_1_exitcond1_r1)? main_1_exitcond1_r0
		: main_1_exitcond1_r2;
end
always @(*) begin
	main_1_exitcond1_reg
		= (main_1_exitcond1_reg_r0==main_1_exitcond1_reg_r1)? main_1_exitcond1_reg_r0
		: main_1_exitcond1_reg_r2;
end
always @(*) begin
	main_5_7
		= (main_5_7_r0==main_5_7_r1)? main_5_7_r0
		: main_5_7_r2;
end


//port drive
always @(posedge clk) begin
	if (reset)
		finish <= 0;
	else if((cur_state == LEGUP_0)) begin
		finish <= 1'd0;
		if (start == 1'b0 && ^(1'd0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to finish"); $finish; end
	end
	/* main: %12*/
	/*   ret i32 %3*/
	else if((cur_state == LEGUP_F_main_BB__12_7)) begin
		finish <= (memory_controller_waitrequest == 1'd0);
		if (start == 1'b0 && ^((memory_controller_waitrequest == 1'd0)) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to finish"); $finish; end
	end
end
always @(*) begin
	memory_controller_enable_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %2 = load i32* %scevgep, align 4, !tbaa !1*/
	if ((cur_state == LEGUP_F_main_BB__1_1)) begin
		memory_controller_enable_a = 1'd1;
	end
end
always @(*) begin
	memory_controller_address_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_address_a = 1'd0;
	end
	/* main: %1*/
	/*   %2 = load i32* %scevgep, align 4, !tbaa !1*/
	if ((cur_state == LEGUP_F_main_BB__1_1)) begin
		memory_controller_address_a = main_1_scevgep;
	end
end
always @(*) begin
	memory_controller_write_enable_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_write_enable_a = 1'd0;
	end
	/* main: %1*/
	/*   %2 = load i32* %scevgep, align 4, !tbaa !1*/
	if ((cur_state == LEGUP_F_main_BB__1_1)) begin
		memory_controller_write_enable_a = 1'd0;
	end
end
always @(*) begin
	memory_controller_in_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_in_a = 1'd0;
	end
end
always @(*) begin
	memory_controller_size_a = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_size_a = 1'd0;
	end
	/* main: %1*/
	/*   %2 = load i32* %scevgep, align 4, !tbaa !1*/
	if ((cur_state == LEGUP_F_main_BB__1_1)) begin
		memory_controller_size_a = 2'd2;
	end
end
always @(*) begin
	memory_controller_enable_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_enable_b = 1'd0;
	end
end
always @(*) begin
	memory_controller_address_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_address_b = 1'd0;
	end
end
always @(*) begin
	memory_controller_write_enable_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_write_enable_b = 1'd0;
	end
end
always @(*) begin
	memory_controller_in_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_in_b = 1'd0;
	end
end
always @(*) begin
	memory_controller_size_b = 1'd0;
	if ((cur_state == LEGUP_0)) begin
		memory_controller_size_b = 1'd0;
	end
end
always @(posedge clk) begin
	if (reset)
		return_val <= 0;
	else if((cur_state == LEGUP_0)) begin
		return_val <= 0;
		if (start == 1'b0 && ^(0) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to return_val"); $finish; end
	end
	/* main: %12*/
	/*   ret i32 %3*/
	else if((cur_state == LEGUP_F_main_BB__12_7)) begin
		return_val <= main_1_3_reg;
		if (start == 1'b0 && ^(main_1_3_reg) === 1'bX) begin $display ("ERROR: Right hand side is 'X'. Assigned to return_val"); $finish; end
	end
end

endmodule 
module ram_dual_port
(
	clk,
	clken,
	address_a,
	address_b,
	wren_a,
	wren_b,
	data_a,
	data_b,
	byteena_a,
	byteena_b,
	q_a,
	q_b
);

parameter  width_a = 1'd0;
parameter  width_b = 1'd0;
parameter  widthad_a = 1'd0;
parameter  widthad_b = 1'd0;
parameter  numwords_a = 1'd0;
parameter  numwords_b = 1'd0;
parameter  init_file = "UNUSED.mif";
parameter  width_be_a = 1'd0;
parameter  width_be_b = 1'd0;
parameter  latency = 1;

input  clk;
input  clken;
input [(widthad_a-1):0] address_a;
input [(widthad_b-1):0] address_b;
output wire [(width_a-1):0] q_a;
output wire [(width_b-1):0] q_b;
reg [(width_a-1):0] q_a_wire;
reg [(width_b-1):0] q_b_wire;
input  wren_a;
input  wren_b;
input [(width_a-1):0] data_a;
input [(width_b-1):0] data_b;
// byte enable is unsupported by inferred RAMs
input [width_be_a-1:0] byteena_a;
input [width_be_b-1:0] byteena_b;

(* ramstyle = "no_rw_check", ram_init_file = init_file *) reg [width_a-1:0] ram[numwords_a-1:0];

/* synthesis translate_off */
integer i;
ALTERA_MF_MEMORY_INITIALIZATION mem ();
reg [8*256:1] ram_ver_file;
initial begin
	if (init_file == "UNUSED.mif")
    begin
		for (i = 0; i < numwords_a; i = i + 1)
			ram[i] = 0;
    end
	else
    begin
        // modelsim can't read .mif files directly. So use Altera function to
        // convert them to .ver files
        mem.convert_to_ver_file(init_file, width_a, ram_ver_file);
        $readmemh(ram_ver_file, ram);
    end
end
/* synthesis translate_on */

always @ (posedge clk)
if (clken)
begin // Port A
if (wren_a)
begin
    ram[address_a] <= data_a;
    q_a_wire <= {width_a{1'bX}};
end
else
    q_a_wire <= ram[address_a];
end
always @ (posedge clk)
if (clken)
begin // Port b
if (wren_b)
begin
    ram[address_b] <= data_b;
    q_b_wire <= {width_b{1'bX}};
end
else
    q_b_wire <= ram[address_b];
end



integer j;
reg [(width_a-1):0] q_a_reg[latency:1], q_b_reg[latency:1];

always @(*)
begin
   q_a_reg[1] <= q_a_wire;
   q_b_reg[1] <= q_b_wire;
end

always @(posedge clk)
if (clken)
begin
   for (j = 1; j < latency; j=j+1)
   begin
       q_a_reg[j+1] <= q_a_reg[j];
       q_b_reg[j+1] <= q_b_reg[j];
   end
end

assign q_a = (clken) ? q_a_reg[latency] : 0;
assign q_b = (clken) ? q_b_reg[latency] : 0;


endmodule
module rom_dual_port
(
	clk,
	clken,
	address_a,
	address_b,
	q_a,
	q_b
);

parameter  width_a = 1'd0;
parameter  width_b = 1'd0;
parameter  widthad_a = 1'd0;
parameter  widthad_b = 1'd0;
parameter  numwords_a = 1'd0;
parameter  numwords_b = 1'd0;
parameter  init_file = "UNUSED.mif";
parameter  latency = 1;

input  clk;
input  clken;
input [(widthad_a-1):0] address_a;
input [(widthad_b-1):0] address_b;
output wire [(width_a-1):0] q_a;
output wire [(width_b-1):0] q_b;
reg [(width_a-1):0] q_a_wire;
reg [(width_b-1):0] q_b_wire;

(* ramstyle = "no_rw_check", ram_init_file = init_file *) reg [width_a-1:0] ram[numwords_a-1:0];

/* synthesis translate_off */
integer i;
ALTERA_MF_MEMORY_INITIALIZATION mem ();
reg [8*256:1] ram_ver_file;
initial begin
	if (init_file == "UNUSED.mif")
    begin
		for (i = 0; i < numwords_a; i = i + 1)
			ram[i] = 0;
    end
	else
    begin
        // modelsim can't read .mif files directly. So use Altera function to
        // convert them to .ver files
        mem.convert_to_ver_file(init_file, width_a, ram_ver_file);
        $readmemh(ram_ver_file, ram);
    end
end
/* synthesis translate_on */

always @ (posedge clk)
if (clken)
begin
    q_a_wire <= ram[address_a];
    q_b_wire <= ram[address_b];
end



integer j;
reg [(width_a-1):0] q_a_reg[latency:1], q_b_reg[latency:1];

always @(*)
begin
   q_a_reg[1] <= q_a_wire;
   q_b_reg[1] <= q_b_wire;
end

always @(posedge clk)
if (clken)
begin
   for (j = 1; j < latency; j=j+1)
   begin
       q_a_reg[j+1] <= q_a_reg[j];
       q_b_reg[j+1] <= q_b_reg[j];
   end
end

assign q_a = (clken) ? q_a_reg[latency] : 0;
assign q_b = (clken) ? q_b_reg[latency] : 0;


endmodule
// Adding code from verilog file: ../../../../boards/Virtex6/ML605/top.v


module ML605 (
       USER_CLOCK,
	    KEY,
	    SW,	    
       LED,
       LEDG,
		UART_RXD,
		UART_TXD

	    );

   input USER_CLOCK;
   input [4:0] KEY;
   input [7:0] SW;
   output [7:0] LED;
   output [7:0] LEDG;
   wire CLOCK_50;

    input UART_RXD;
    output UART_TXD;    
	wire clk = CLOCK_50;
	wire go = ~KEY[1];



   wire 	reset = ~KEY[0];
   wire 	start;
   wire [31:0] 	return_val;
   reg  [31:0] 	return_val_reg;
   wire 	finish;
   wire [3:0]	state;
   
   reg [6:0]   hex0, hex1, hex2, hex3, hex4, hex5, hex6, hex7;

   assign CLOCK_50 = USER_CLOCK;
   assign LED = 0;
   
	always @ (*) begin
		hex7 <= return_val_reg[31:28];
		hex6 <= return_val_reg[27:24];
		hex5 <= return_val_reg[23:20];
		hex4 <= return_val_reg[19:16];
		hex3 <= return_val_reg[15:12];
		hex2 <= return_val_reg[11:8];
		hex1 <= return_val_reg[7:4];
		hex0 <= return_val_reg[3:0];
	end
assign UART_TXD = 1'b0;

    parameter s_WAIT = 3'b001, s_START = 3'b010, s_EXE = 3'b011,
                s_DONE = 3'b100;

    // state registers
    reg [3:0] y_Q, Y_D;

    assign LEDG[3:0] = y_Q;

    // next state
    always @(*)
    begin
        case (y_Q)
            s_WAIT: if (go) Y_D = s_START; else Y_D = y_Q;

            s_START: Y_D = s_EXE;

            s_EXE: if (!finish) Y_D = s_EXE; else Y_D = s_DONE;

            s_DONE: Y_D = s_DONE;

            default: Y_D = 3'bxxx;
        endcase
    end

    // current state
    always @(posedge clk)
    begin
        if (reset) // synchronous clear
            y_Q <= s_WAIT;
        else
            y_Q <= Y_D;
    end

    always @(posedge clk)
        if (y_Q == s_EXE && finish)
            return_val_reg <= return_val;
        else if (y_Q == s_DONE)
            return_val_reg <= return_val_reg;
        else
            return_val_reg <= 0;


    assign start = (y_Q == s_START);

   
   top top_inst (
      .clk (clk),
      .reset (reset),
      .finish (finish),
      .return_val (return_val),
        .start (start)

    );

   

endmodule

// Adding code from verilog file: ../../../../boards/StratixIV/DE4/top.v


module de4 ( 
    	     OSC_50_BANK2, 
             BUTTON, 
             LED, 
    	     SEG0_D, 
    	     SEG1_D 
	     ); 
   input OSC_50_BANK2; 
   input [1:0] BUTTON; 
   output [6:0] SEG0_D; 
   output [6:0] SEG1_D; 
   output [7:0] LED; 
   
   de2 de2_inst ( 
		  .CLOCK_50 (OSC_50_BANK2), 
		  .LEDG (LED), 
		  .KEY (BUTTON), 
		  .SW (), 
		  .HEX0 (SEG0_D), 
		  .HEX1 (SEG1_D), 
		  .HEX2 (), 
		  .HEX3 (), 
		  .HEX4 (), 
		  .HEX5 (), 
		  .HEX6 (), 
		  .HEX7 () 
		  ); 
   
endmodule
// Adding code from verilog file: ../../../../boards/CycloneII/DE2/top.v


module de2(
	input         iCLK_50,
	input  [17:0] iSW,
	input  [ 3:0] iKEY,
	output [17:0] oLEDR,
	output [ 8:0] oLEDG,
	output [ 7:0] oHEX0_D,
	output [ 7:0] oHEX1_D,
	output [ 7:0] oHEX2_D,
	output [ 7:0] oHEX3_D,
	output [ 7:0] oHEX4_D,
	output [ 7:0] oHEX5_D,
	output [ 7:0] oHEX6_D,
	output [ 7:0] oHEX7_D
	//output [19:0] oSRAM_A,
	//output        oSRAM_ADSC_N,
	//output        oSRAM_ADSP_N,
	//output        oSRAM_ADV_N,
	//output [ 3:0] oSRAM_BE_N,
	//output        oSRAM_CE1_N,
	//output        oSRAM_CE2,
	//output        oSRAM_CE3_N,
	//output        oSRAM_CLK,
	//inout  [ 3:0] SRAM_DPA,
	//inout  [31:0] SRAM_DQ,
	//output        oSRAM_GW_N,
	//output        oSRAM_OE_N,
	//output        oSRAM_WE_N
);

wire clk;
wire nReset = iKEY[0];

assign clk = iCLK_50;
//clockGen clockGen(
//	.inclk0(iCLK_50),
//	.c0(clk)
//);

reg [3:0] rKEY, rKEY_d1;
always @(posedge clk or negedge nReset) begin
	if(!nReset) begin
		rKEY <= 0;
		rKEY_d1 <= 0;
	end
	else begin
		rKEY <= ~iKEY;
		rKEY_d1 <= rKEY;
	end
end

wire start = rKEY[1] & ~rKEY_d1[1];
wire finish;
wire [31:0] return_val;
wire reset = ~nReset;

reg        rFinish;
reg [31:0] rRet;
always @(posedge clk or negedge nReset) begin
	if(!nReset) begin
		rRet <= 0;
		rFinish <= 0;
	end
	else if(finish) begin
		rRet <= return_val;
		rFinish <= 1;
	end
end

assign oLEDG[8] = rFinish;

assign oHEX7_D = HEX2SEG(rRet[4*7+3:4*7]);
assign oHEX6_D = HEX2SEG(rRet[4*6+3:4*6]);
assign oHEX5_D = HEX2SEG(rRet[4*5+3:4*5]);
assign oHEX4_D = HEX2SEG(rRet[4*4+3:4*4]);
assign oHEX3_D = HEX2SEG(rRet[4*3+3:4*3]);
assign oHEX2_D = HEX2SEG(rRet[4*2+3:4*2]);
assign oHEX1_D = HEX2SEG(rRet[4*1+3:4*1]);
assign oHEX0_D = HEX2SEG(rRet[4*0+3:4*0]);

top top_inst(
	.clk(clk),
	.reset(reset),
	.finish(finish),
	.return_val(return_val),
	.start(start)
);

function [7:0] HEX2SEG;
	input [3:0] num;
begin
	if     (num==4'h0) HEX2SEG = 8'b11000000;
	else if(num==4'h1) HEX2SEG = 8'b11111001;
	else if(num==4'h2) HEX2SEG = 8'b10100100;
	else if(num==4'h3) HEX2SEG = 8'b10110000;
	else if(num==4'h4) HEX2SEG = 8'b10011001;
	else if(num==4'h5) HEX2SEG = 8'b10010010;
	else if(num==4'h6) HEX2SEG = 8'b10000010;
	else if(num==4'h7) HEX2SEG = 8'b11111000;
	else if(num==4'h8) HEX2SEG = 8'b10000000;
	else if(num==4'h9) HEX2SEG = 8'b10010000;
	else if(num==4'hA) HEX2SEG = 8'b10001000;
	else if(num==4'hb) HEX2SEG = 8'b10000011;
	else if(num==4'hC) HEX2SEG = 8'b11000110;
	else if(num==4'hd) HEX2SEG = 8'b10100001;
	else if(num==4'hE) HEX2SEG = 8'b10000110;
	else if(num==4'hF) HEX2SEG = 8'b10001110;
	else               HEX2SEG = 8'b11111111;
end
endfunction

endmodule


module circuit_start_control (
    go,
    control_key
);
    input control_key;
    output go;
    assign go = control_key;
endmodule
module hex_digits(x, hex_LEDs);
    input [3:0] x;
    output [6:0] hex_LEDs;
    
    assign hex_LEDs[0] = (~x[3] & ~x[2] & ~x[1] & x[0]) |
                            (~x[3] & x[2] & ~x[1] & ~x[0]) |
                            (x[3] & x[2] & ~x[1] & x[0]) |
                            (x[3] & ~x[2] & x[1] & x[0]);
    assign hex_LEDs[1] = (~x[3] & x[2] & ~x[1] & x[0]) |
                            (x[3] & x[1] & x[0]) |
                            (x[3] & x[2] & ~x[0]) |
                            (x[2] & x[1] & ~x[0]);
    assign hex_LEDs[2] = (x[3] & x[2] & ~x[0]) |
                            (x[3] & x[2] & x[1]) |
                            (~x[3] & ~x[2] & x[1] & ~x[0]);
    assign hex_LEDs[3] = (~x[3] & ~x[2] & ~x[1] & x[0]) | 
                            (~x[3] & x[2] & ~x[1] & ~x[0]) | 
                            (x[2] & x[1] & x[0]) | 
                            (x[3] & ~x[2] & x[1] & ~x[0]);
    assign hex_LEDs[4] = (~x[3] & x[0]) |
                            (~x[3] & x[2] & ~x[1]) |
                            (~x[2] & ~x[1] & x[0]);
    assign hex_LEDs[5] = (~x[3] & ~x[2] & x[0]) | 
                            (~x[3] & ~x[2] & x[1]) | 
                            (~x[3] & x[1] & x[0]) | 
                            (x[3] & x[2] & ~x[1] & x[0]);
    assign hex_LEDs[6] = (~x[3] & ~x[2] & ~x[1]) | 
                            (x[3] & x[2] & ~x[1] & ~x[0]) | 
                            (~x[3] & x[2] & x[1] & x[0]);
    
endmodule
`timescale 1 ns / 1 ns
module main_tb
(
);

integer i;
reg  clk;
reg  reset;
reg  start;
reg  waitrequest;
wire [31:0] return_val;
wire  finish;


top top_inst_r0 (
	.clk (clk),
	.reset (reset),
	.start (start),
	.waitrequest (waitrequest),
	.finish (finish),
	.return_val (return_val)
);





//voter


//port drive

initial 
    clk = 0;
always @(clk)
    clk <= #10 ~clk;

initial begin
//$monitor("At t=%t clk=%b %b %b %b %d", $time, clk, reset, start, finish, return_val);
@(negedge clk);
reset <= 1;
@(negedge clk);
reset <= 0;
start <= 1;
@(negedge clk);
start <= 0;
end

always@(finish) begin
    if (finish == 1) begin
        $display("At t=%t clk=%b finish=%b return_val=%d", $time, clk, finish, return_val);
        $display("Cycles: %d", ($time-50)/20);
        $finish;
    end
end

initial begin
waitrequest <= 1;
@(negedge clk);
@(negedge clk);
waitrequest <= 0;
end


endmodule 
